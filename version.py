# coding: utf-8
#
# Author: Sergey Vasilyev <nolar@nolar.info>
#
# Based on a concept from Douglas Creager <dcreager@dcreager.net>
# from http://dcreager.net/2010/02/10/setuptools-git-version-numbers/
# and https://raw.github.com/gist/1026179/b850b4a713a17a4b289a82d9aae97f6ef79cd883/version.py
#
# But instead of storing version in a plain-text file in the root dir,
# it is stored in version.py file inside the main library package dir.
# In this case, the version info can be imported by modules and packages,
# and can be used for the generation of HTTP User-Agent headers or so.
#
# You have no need to add version file to MANIFEST.in, since version file
# is a python source code file and will be detected by setuptools automatically.
# It is a good idea, though, to add version file to ".gitignore".
#
# Suggested release scenario is as follows:
#
# 1. Make all neccessary commits on release branch. Master is okay for this,
#    but you can use special release-dedicated branch if you want so.
#
# 2. Create a tag with the version number as-is (i.e., with no decorations).
#    For example, `git tag [-s|-a] 0.1` for version 0.1.
#
# 3. Run `setup.py sdist` and make all other disttributions if needed.
#    This will update the version file in git working copy, and distribute it.
#    Since version file is not under revision control, no additional commits needed.
#
# 4. Continue your development, and run `setup.py version` time to time
#    to update version file to post-release versions like '0.1-13-abcdef'.
#    Thus, updated post-release versions will be used for User-Agent, etc.
#
# 5. For version maintenance, fork a new branch from the tagged commit from step 2,
#    apply the patches, then release a new version (0.1.1, for example) as usually.
#
# To use this script, simply import it your setup.py file, and use the results
# of get_version() as your package version:
#
#   from version import get_version
#   setup(
#       version=get_version(allow_update=True),
#       .
#       .
#       .
#   )
#
# This will automatically update the version file, if necessary, on each
# and every call to setup.py. If you want to update version file only when
# explicitly requested, use get_version() with no parameters -- this is
# just a read-only mode.
#

__all__ = ("get_git_version")

from subprocess import Popen, PIPE
import re
import contextlib

VERSION_PY_PATH = "tootwi/_version.py"
VERSION_PY_TEXT = """
# This file is generated by running 'setup.py version'.
# Distributions contain a pre-generated copy of this file.
# It should never be added to revision control system.

__version__ = '%s'
""".lstrip()
VERSION_PY_REGEXP = re.compile(re.escape(VERSION_PY_TEXT).replace('\\%s', r'(.*?)'))


def call_git_describe(abbrev=4):
    try:
        p = Popen(['git', 'describe', '--abbrev=%d' % abbrev],
                  stdout=PIPE, stderr=PIPE)
        p.stderr.close()
        line = p.stdout.readlines()[0]
        return line.strip()
    except:
        return None

def read_release_version():
    try:
        with contextlib.closing(open(VERSION_PY_PATH, "rt")) as f:
            content = f.read()
            matches = VERSION_PY_REGEXP.match(content)
            if matches:
                return matches.group(1)
            else:
                return None#??? raise ValueError("Version file is found, but cannot be parsed.")
    except:
        return None#??? raise ValueError("Version file is not found or unreadable.")

def write_release_version(version):
    with contextlib.closing(open(VERSION_PY_PATH, "wt")) as f:
        f.write(VERSION_PY_TEXT % version)

def get_version(abbrev=4, allow_update=False, force_update=False):
    """
    Calculates the current version number.  If possible, this is the
    output of "git describe", modified to conform to the versioning
    scheme that setuptools uses.  If "git describe" returns an error
    (most likely because we're in an unpacked copy of a release tarball,
    rather than in a git working copy), then we fall back on reading the
    contents of the version file.
    """

    # Read version information, both prepared and current.
    release_version = read_release_version()
    current_version = call_git_describe(abbrev)
    
    # If we are not in a working copy, fall back on the value from version file.
    if current_version is None:
        current_version = release_version
    
    # If we still don't have anything, that's an error.
    if current_version is None:
        raise ValueError("Cannot find the version number!")
    
    # If the current version is different from what's in the version file,
    # update the version file to be current.
    if force_update or (allow_update and current_version != release_version):
        write_release_version(current_version)
    
    # Finally, return the current version.
    return current_version


if __name__ == "__main__":
    print get_version()
